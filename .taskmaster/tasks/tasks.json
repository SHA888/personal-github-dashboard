{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Infrastructure",
        "description": "Set up the initial project structure with Vite, React, TypeScript, and Tailwind for frontend, and Rust with Actix-web for backend. Configure Docker Compose for local development.",
        "details": "1. Create frontend project:\n   - Use Vite to scaffold a React + TypeScript project\n   - Install and configure Tailwind CSS\n   - Set up folder structure (components, hooks, services, types)\n   - Configure ESLint and Prettier\n\n2. Create backend project:\n   - Initialize a new Rust project with Cargo\n   - Add Actix-web, Tokio, and other dependencies\n   - Set up folder structure (routes, models, services, utils)\n   - Create health endpoint at GET /api/health\n\n3. Create Docker Compose setup:\n   - Frontend container\n   - Backend container\n   - PostgreSQL container\n   - Redis container\n   - Configure environment variables\n   - Set up volume mounts for development\n\n4. Configure CI pipeline:\n   - Basic linting and testing\n   - Build verification",
        "testStrategy": "1. Verify Docker Compose setup works by running `docker-compose up`\n2. Confirm all services start without errors\n3. Test health endpoint returns 200 OK\n4. Verify frontend development server runs and connects to backend\n5. Run linting and type checking on both frontend and backend",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Database Schema and Migrations",
        "description": "Implement the database schema as defined in the PRD, including tables for users, oauth_tokens, repositories, user_repositories, issues, pull_requests, events, and views for work items and analytics.",
        "details": "1. Create database migration system using sqlx or diesel\n2. Implement the following tables:\n   - users (id, github_user_id, login, name, avatar, email, created_at)\n   - oauth_tokens (user_id, provider, access_token_enc, refresh_token_enc, scope, expires_at)\n   - repositories (id, owner, name, is_private, default_branch)\n   - user_repositories (user_id, repo_id, role, is_following)\n   - issues (id, repo_id, number, title, state, labels[], assignees[], created_at, updated_at, closed_at)\n   - pull_requests (id, repo_id, number, title, state, draft, requested_reviewers[], additions, deletions, created_at, merged_at, closed_at)\n   - events (id, repo_id, type, actor, payload_json, created_at)\n   - user_settings (user_id, settings_json, updated_at)\n3. Create materialized view for work_items_view (union of issues/PRs/reviews)\n4. Create analytics_aggregates table for metrics\n5. Implement encryption for sensitive fields (OAuth tokens)\n6. Set up indexes for common query patterns",
        "testStrategy": "1. Write unit tests for database models\n2. Test migrations up and down\n3. Verify encryption/decryption of sensitive fields\n4. Test query performance for common access patterns\n5. Validate foreign key constraints and cascading behavior",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Database Migration System Setup",
            "description": "Set up the database migration system using sqlx or diesel to manage schema changes and versioning.",
            "dependencies": [],
            "details": "1. Research and select between sqlx and diesel based on project requirements\n2. Configure the migration system in the project structure\n3. Set up the database connection pool configuration\n4. Create initial migration files structure\n5. Implement migration runner for up/down migrations\n6. Add CI/CD integration for automated migrations\n7. Document migration procedures for development and production environments",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Core Tables Implementation",
            "description": "Implement the primary database tables for users, repositories, issues, and pull requests.",
            "dependencies": [
              "2.1"
            ],
            "details": "1. Create users table with fields: id, github_user_id, login, name, avatar, email, created_at\n2. Create repositories table with fields: id, owner, name, is_private, default_branch\n3. Create issues table with fields: id, repo_id, number, title, state, labels[], assignees[], created_at, updated_at, closed_at\n4. Create pull_requests table with fields: id, repo_id, number, title, state, draft, requested_reviewers[], additions, deletions, created_at, merged_at, closed_at\n5. Implement proper data types for array fields (labels, assignees, reviewers)\n6. Add appropriate primary keys and constraints\n7. Write tests for table creation and basic CRUD operations",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Relationship Tables Implementation",
            "description": "Implement tables that manage relationships between core entities, including user_repositories, oauth_tokens, and events.",
            "dependencies": [
              "2.2"
            ],
            "details": "1. Create oauth_tokens table with fields: user_id, provider, access_token_enc, refresh_token_enc, scope, expires_at\n2. Create user_repositories table with fields: user_id, repo_id, role, is_following\n3. Create events table with fields: id, repo_id, type, actor, payload_json, created_at\n4. Create user_settings table with fields: user_id, settings_json, updated_at\n5. Implement foreign key constraints to maintain referential integrity\n6. Add appropriate indexes for relationship lookups\n7. Write tests for relationship constraints and cascading behavior",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Views and Aggregates Creation",
            "description": "Create materialized views and aggregate tables for work items and analytics to optimize query performance.",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "details": "1. Design and implement work_items_view as a materialized view that unions issues, PRs, and reviews\n2. Create analytics_aggregates table for storing pre-computed metrics\n3. Implement refresh mechanism for materialized views\n4. Add indexes on views for common query patterns\n5. Create helper functions for view maintenance\n6. Implement query optimization for common access patterns\n7. Write tests to verify view data integrity and performance",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Security Implementation",
            "description": "Implement security features including encryption for sensitive fields and proper indexing for query optimization.",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3"
            ],
            "details": "1. Research and implement encryption mechanism for OAuth tokens\n2. Create helper functions for encrypting/decrypting sensitive data\n3. Set up indexes for common query patterns across all tables\n4. Implement row-level security policies if needed\n5. Add database-level validation for critical fields\n6. Configure proper access controls for database users\n7. Write tests to verify encryption works correctly and sensitive data is protected\n8. Document security measures implemented for the database",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "GitHub OAuth Authentication",
        "description": "Implement GitHub OAuth authentication flow, JWT session management, and secure token storage as specified in the PRD.",
        "details": "1. Create GitHub OAuth App in GitHub Developer Settings\n2. Implement authentication endpoints:\n   - GET /auth/login: Redirect to GitHub OAuth\n   - GET /auth/callback: Handle OAuth callback, create user, store tokens\n   - POST /auth/logout: Invalidate session\n   - GET /me: Return current user profile\n3. Implement JWT authentication:\n   - Generate short-lived JWTs with user info\n   - Implement refresh token mechanism\n   - Create middleware for protected routes\n4. Secure token storage:\n   - Encrypt OAuth tokens before storing in database\n   - Implement token refresh when expired\n5. Handle scopes: read:user, user:email, repo, read:org\n6. Create AuthContext in React for frontend auth state",
        "testStrategy": "1. Test OAuth flow with mock GitHub responses\n2. Verify token encryption/decryption\n3. Test JWT generation, validation, and refresh\n4. Test protected routes with and without valid tokens\n5. Verify error handling for invalid/expired tokens\n6. Test frontend auth context with various auth states",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "GitHub API Integration and Sync Service",
        "description": "Implement the GitHub API integration and sync service to fetch and store repository data, issues, PRs, and review requests with proper rate limit handling.",
        "details": "1. Create GitHub API client in Rust:\n   - Implement REST and GraphQL API clients\n   - Handle authentication with user tokens\n   - Implement rate limit detection and backoff\n   - Use ETag/If-None-Match for efficient polling\n2. Implement sync service with Tokio:\n   - Background worker for periodic polling\n   - On-demand sync endpoint\n   - Prioritize \"My Work\" queries over other data\n3. Implement repository sync:\n   - Fetch and store basic repo information\n   - Sync issues assigned to user\n   - Sync PRs authored by or assigned to user\n   - Sync review requests\n4. Implement sync endpoints:\n   - POST /api/sync/repository/{owner}/{repo}\n5. Handle error cases:\n   - Rate limiting with exponential backoff\n   - Token revocation/expiration\n   - Network failures",
        "testStrategy": "1. Mock GitHub API responses for testing\n2. Test rate limit detection and backoff behavior\n3. Verify ETag usage reduces unnecessary data transfer\n4. Test background sync with various schedules\n5. Verify data consistency after sync\n6. Test error handling and recovery\n7. Measure sync performance and optimize",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "GitHub API Client Implementation",
            "description": "Create a robust GitHub API client in Rust that supports both REST and GraphQL APIs with authentication, rate limiting, and efficient polling.",
            "dependencies": [],
            "details": "1. Implement REST API client with reqwest:\n   - Create modular endpoints for repos, issues, PRs, and reviews\n   - Implement serialization/deserialization with serde\n   - Add proper error handling and response parsing\n2. Implement GraphQL API client:\n   - Create query builder for common GitHub GraphQL queries\n   - Implement response parsing for complex nested data\n3. Add authentication handling:\n   - Support GitHub personal access tokens\n   - Implement token validation and refresh logic\n4. Implement efficient polling:\n   - Add ETag/If-None-Match header support\n   - Store and use ETags for subsequent requests\n5. Add comprehensive test suite with mocked responses",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Background Sync Service with Tokio",
            "description": "Implement a background sync service using Tokio for asynchronous processing of GitHub data with configurable polling intervals.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Set up Tokio runtime for background processing:\n   - Configure thread pool and worker configuration\n   - Implement graceful shutdown handling\n2. Create sync scheduler:\n   - Implement configurable polling intervals\n   - Add priority queue for sync tasks\n   - Ensure \"My Work\" queries have higher priority\n3. Implement sync state management:\n   - Track last sync time per repository\n   - Store sync status (success/failure/in-progress)\n4. Add on-demand sync endpoint:\n   - Implement POST /api/sync/repository/{owner}/{repo}\n   - Handle immediate sync requests\n5. Create metrics collection for sync performance",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Repository Data Synchronization",
            "description": "Implement the core repository data synchronization logic to fetch and store basic repository information in the database.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "1. Create repository sync module:\n   - Fetch basic repository metadata (name, description, stars, etc.)\n   - Sync repository branches and their protection status\n   - Update repository visibility and access information\n2. Implement database storage for repository data:\n   - Create/update repository records\n   - Store repository metadata efficiently\n3. Add incremental sync logic:\n   - Only fetch changed data using ETags\n   - Implement delta updates to minimize database writes\n4. Create repository search functionality:\n   - Sync repositories the user has access to\n   - Support filtering by organization/owner\n5. Add tests for repository sync with mock GitHub API responses",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Work Items Synchronization",
            "description": "Implement synchronization for work items including issues, pull requests, and review requests with proper filtering for user relevance.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3"
            ],
            "details": "1. Implement issues sync:\n   - Fetch issues assigned to the user\n   - Sync issue metadata (labels, milestones, etc.)\n   - Store issue comments and activity\n2. Implement pull requests sync:\n   - Fetch PRs authored by or assigned to user\n   - Sync PR status (CI status, approvals, etc.)\n   - Store PR diffs and changed files metadata\n3. Implement review requests sync:\n   - Fetch review requests for the user\n   - Sync review comments and feedback\n   - Track review status changes\n4. Add relevance filtering:\n   - Prioritize items directly related to user\n   - Implement configurable filters for work items\n5. Create database models and storage logic for all work items",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Error Handling & Rate Limiting",
            "description": "Implement comprehensive error handling and rate limit management for the GitHub API integration with exponential backoff and recovery strategies.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Implement rate limit detection:\n   - Parse GitHub rate limit headers\n   - Track remaining requests and reset times\n   - Add predictive rate limit avoidance\n2. Create exponential backoff strategy:\n   - Implement configurable backoff algorithm\n   - Add jitter to prevent thundering herd\n   - Set maximum retry attempts\n3. Handle authentication errors:\n   - Detect token revocation/expiration\n   - Implement token refresh or user notification\n4. Add network failure handling:\n   - Implement retry logic for transient errors\n   - Add circuit breaker for persistent failures\n5. Create comprehensive error reporting:\n   - Log detailed error information\n   - Provide user-friendly error messages\n   - Track error metrics for monitoring",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Work Items Prioritization Engine",
        "description": "Implement the prioritization engine that scores and ranks work items (issues, PRs, reviews) based on the scoring model defined in the PRD.",
        "details": "1. Implement scoring algorithm:\n   - Calculate base score for each work item\n   - Apply weights based on signals (assignment, review request, labels, etc.)\n   - Handle special cases (draft PRs, WIP labels)\n2. Create presets for different roles:\n   - IC preset\n   - Reviewer preset\n   - Maintainer preset\n3. Implement settings storage and retrieval:\n   - Store user preferences in user_settings table\n   - Allow customization of weights\n4. Create score breakdown calculation:\n   - Track contribution of each factor to final score\n   - Format for display in UI\n5. Optimize for performance:\n   - Consider caching scores\n   - Batch update on sync",
        "testStrategy": "1. Unit test scoring algorithm with various inputs\n2. Verify preset configurations produce expected results\n3. Test edge cases (missing data, extreme values)\n4. Benchmark performance with large datasets\n5. Verify score breakdown matches total score\n6. Test customization of weights affects scores as expected",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Scoring Algorithm Implementation",
            "description": "Implement the core scoring algorithm that calculates and ranks work items based on various signals and weights.",
            "dependencies": [],
            "details": "1. Implement base score calculation for different work item types (issues, PRs, reviews)\n2. Add signal weight application logic (assignment, review request, mentions, labels)\n3. Implement special case handling (draft PRs, WIP labels, stale items)\n4. Create score normalization function to ensure consistent scoring across different item types\n5. Add unit tests with various input combinations\n6. Implement performance optimizations including score caching\n7. Create batch update mechanism for efficient rescoring during sync\n\nAcceptance Criteria:\n- Algorithm correctly calculates scores based on defined weights\n- Special cases are properly handled with appropriate score adjustments\n- Unit tests pass with >90% coverage\n- Performance benchmarks show scoring of 1000+ items in under 1 second",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Role Presets Creation",
            "description": "Implement predefined scoring presets for different user roles (IC, Reviewer, Maintainer) with appropriate weight configurations.",
            "dependencies": [
              "5.1"
            ],
            "details": "1. Define weight configurations for each preset:\n   - IC preset: prioritize assigned issues and PRs\n   - Reviewer preset: prioritize review requests and team PRs\n   - Maintainer preset: balanced view with emphasis on critical issues\n2. Create preset application logic to apply weights to scoring algorithm\n3. Implement preset switching functionality\n4. Add default preset selection based on user activity patterns\n5. Create unit tests for each preset configuration\n\nAcceptance Criteria:\n- All three presets are implemented with distinct and appropriate weight configurations\n- Presets can be applied and switched without requiring application restart\n- Each preset produces expected prioritization results in test scenarios\n- Default preset selection logic works correctly based on user activity",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "User Settings Integration",
            "description": "Implement the storage and retrieval of user preferences for prioritization weights in the user_settings table.",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "1. Design schema for storing prioritization weights in user_settings table\n2. Implement settings retrieval logic to load user preferences\n3. Create settings update functionality to save custom weight configurations\n4. Add validation for weight values to ensure they're within acceptable ranges\n5. Implement default settings application for new users\n6. Create migration script for settings table schema\n7. Add unit tests for settings storage and retrieval\n\nAcceptance Criteria:\n- User preferences are correctly stored in the database\n- Custom weight configurations are properly applied to the scoring algorithm\n- Default settings are applied for new users\n- Weight validation prevents invalid configurations\n- Settings changes are immediately reflected in prioritization results",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Score Breakdown Calculation",
            "description": "Implement detailed score breakdown calculation to show how each factor contributes to the final score of a work item.",
            "dependencies": [
              "5.1"
            ],
            "details": "1. Modify scoring algorithm to track contribution of each factor\n2. Create data structure to store score breakdown components\n3. Implement formatting logic for UI display of score breakdowns\n4. Add percentage calculation to show relative importance of each factor\n5. Create API endpoint to retrieve score breakdown for a specific work item\n6. Implement caching for score breakdowns to improve performance\n7. Add unit tests for breakdown calculation accuracy\n\nAcceptance Criteria:\n- Score breakdown correctly shows contribution of each factor\n- Sum of breakdown components equals the total score\n- Percentage calculations accurately reflect relative importance\n- API endpoint returns properly formatted breakdown data\n- Performance impact of tracking breakdowns is minimal",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "My Work API and Frontend",
        "description": "Implement the \"My Work\" prioritized list API and frontend components to display issues, PRs, and review requests with scoring transparency.",
        "details": "1. Implement API endpoint:\n   - GET /api/work-items with filtering and sorting\n   - Include score breakdown in response\n2. Create frontend components:\n   - WorkItemList component\n   - WorkItemCard component with expandable details\n   - Filtering and sorting controls\n   - Score breakdown visualization\n3. Implement real-time updates:\n   - Set up SSE endpoint at GET /api/stream\n   - Create client-side event listener\n   - Update UI when new data arrives\n4. Add quick actions:\n   - Link to GitHub item\n   - Mark as read/unread\n   - Change status (where applicable)\n5. Implement responsive design for mobile/desktop",
        "testStrategy": "1. Test API endpoints with various filter combinations\n2. Verify sorting works correctly\n3. Test real-time updates with simulated sync events\n4. Verify UI renders correctly with different data shapes\n5. Test responsive design on various screen sizes\n6. Verify quick actions perform expected operations\n7. Test accessibility of UI components",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Repository List and Health Stats",
        "description": "Implement the repository list view with basic health statistics including open issues/PRs and stale counts.",
        "details": "1. Implement API endpoints:\n   - GET /api/repos\n   - POST /api/repos/{id}/follow\n2. Create frontend components:\n   - RepositoryList component\n   - RepositoryCard with health stats\n   - Follow/unfollow functionality\n3. Implement health statistics calculation:\n   - Count open issues/PRs\n   - Calculate stale items (>7 days no activity)\n   - Show trend indicators\n4. Add repository search and filtering:\n   - Filter by name/organization\n   - Sort by activity/health\n5. Implement repository selection for onboarding",
        "testStrategy": "1. Test API endpoints for repository listing and following\n2. Verify health statistics calculations are accurate\n3. Test search and filtering functionality\n4. Verify follow/unfollow updates user_repositories correctly\n5. Test UI rendering with various repository states\n6. Verify trend indicators reflect actual changes",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Analytics Implementation",
        "description": "Implement the analytics features including PR cycle time, stale items, and review queue length calculations and visualizations.",
        "details": "1. Implement analytics calculation service:\n   - PR Cycle Time: merged_at − first_commit_timestamp\n   - Review Turnaround Time: first_review_submitted_at − review_requested_at\n   - Time in State tracking\n   - Throughput calculations\n   - WIP counting\n   - Stale item detection and aging buckets\n   - PR size categorization\n2. Create analytics API endpoints:\n   - GET /api/analytics/repository/{owner}/{repo}/activity\n   - GET /api/analytics/repository/{owner}/{repo}/trends\n   - GET /api/analytics/repository/{owner}/{repo}/summary\n3. Implement frontend visualizations:\n   - Time series charts for trends\n   - Summary statistics cards\n   - Stale item breakdown\n   - PR size distribution\n4. Add data aggregation for performance:\n   - Daily rollups in analytics_aggregates\n   - Optimize queries with materialized views",
        "testStrategy": "1. Unit test analytics calculations with known inputs\n2. Verify aggregation logic produces correct results\n3. Test API endpoints with various time ranges\n4. Verify visualization components render correctly\n5. Test performance with large datasets\n6. Verify data consistency between raw and aggregated data",
        "priority": "medium",
        "dependencies": [
          2,
          4,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analytics Calculation Service",
            "description": "Implement the core analytics calculation service that computes metrics like PR cycle time, review turnaround time, and other key performance indicators.",
            "dependencies": [],
            "details": "1. Create a dedicated analytics module with calculation functions for:\n   - PR Cycle Time (merged_at − first_commit_timestamp)\n   - Review Turnaround Time (first_review_submitted_at − review_requested_at)\n   - Time in State tracking with state transition history\n   - Throughput calculations (completed items per time period)\n   - WIP counting and limits monitoring\n   - Stale item detection with configurable thresholds\n   - PR size categorization based on lines changed\n2. Implement unit tests with known inputs and expected outputs\n3. Add caching layer for expensive calculations\n4. Create documentation for calculation methodologies\n\nAcceptance Criteria:\n- All calculations produce correct results for test datasets\n- Performance meets requirements (calculations complete in <500ms)\n- Edge cases are properly handled (missing data, outliers)\n- Calculation methods are well-documented",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Analytics API Endpoints",
            "description": "Create the REST API endpoints that expose the analytics data to the frontend, including activity, trends, and summary endpoints.",
            "dependencies": [
              "8.1"
            ],
            "details": "1. Implement the following API endpoints:\n   - GET /api/analytics/repository/{owner}/{repo}/activity\n     - Parameters: start_date, end_date, granularity (day/week/month)\n     - Returns: Time series data of activity metrics\n   - GET /api/analytics/repository/{owner}/{repo}/trends\n     - Parameters: start_date, end_date, metrics[]\n     - Returns: Trend analysis with percentage changes\n   - GET /api/analytics/repository/{owner}/{repo}/summary\n     - Returns: Current snapshot of key metrics\n2. Add proper error handling and validation\n3. Implement request caching with appropriate cache invalidation\n4. Create comprehensive API documentation\n\nAcceptance Criteria:\n- All endpoints return correctly formatted JSON responses\n- Endpoints handle invalid parameters gracefully\n- Response times are under 1 second for typical requests\n- API documentation is complete and accurate",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Visualization Components",
            "description": "Develop frontend visualization components to display analytics data in an intuitive and interactive way.",
            "dependencies": [
              "8.2"
            ],
            "details": "1. Create reusable chart components using a library like Chart.js or D3:\n   - Time series line charts for trend visualization\n   - Bar charts for distribution analysis\n   - Heatmaps for activity patterns\n   - Gauge charts for KPI visualization\n2. Implement dashboard components:\n   - Summary statistics cards with key metrics\n   - Stale item breakdown with aging buckets\n   - PR size distribution visualization\n   - Team performance indicators\n3. Add interactive features:\n   - Date range selection\n   - Drill-down capabilities\n   - Metric comparison views\n4. Ensure responsive design for all screen sizes\n\nAcceptance Criteria:\n- All visualizations render correctly with sample data\n- Components are responsive across different screen sizes\n- Interactions (hover, click, filter) work as expected\n- Loading states and error handling are implemented",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Data Aggregation System",
            "description": "Implement a data aggregation system to optimize performance for analytics queries by pre-computing common metrics.",
            "dependencies": [
              "8.1"
            ],
            "details": "1. Design and implement analytics_aggregates table structure:\n   - Daily rollups of key metrics\n   - Repository-level aggregations\n   - User-level aggregations\n2. Create scheduled jobs to update aggregates:\n   - Daily aggregation job\n   - Weekly aggregation job\n   - Monthly aggregation job\n3. Implement materialized views for common queries:\n   - PR cycle time distribution\n   - Review turnaround time trends\n   - Stale item counts by category\n4. Add refresh strategies and triggers for materialized views\n5. Create migration scripts for the new tables and views\n\nAcceptance Criteria:\n- Aggregation jobs complete successfully within time constraints\n- Query performance improves by at least 50% when using aggregates\n- Data consistency is maintained between raw and aggregated data\n- System handles backfilling of historical data correctly",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "User Settings and Preferences",
        "description": "Implement user settings management including prioritization weights, repository selection, and notification preferences.",
        "details": "1. Implement settings API endpoints:\n   - GET /api/settings/prioritization\n   - PUT /api/settings/prioritization\n   - GET /api/settings/repos\n   - PUT /api/settings/repos\n2. Create settings UI components:\n   - Settings page layout\n   - Prioritization weight sliders\n   - Repository selection interface\n   - Notification preferences\n3. Implement settings persistence:\n   - Store in user_settings table\n   - Handle validation and defaults\n4. Add preset selection:\n   - IC / Reviewer / Maintainer presets\n   - Custom option with manual weights",
        "testStrategy": "1. Test settings API endpoints for retrieval and update\n2. Verify validation of settings values\n3. Test preset application sets correct weights\n4. Verify UI components update when settings change\n5. Test persistence of settings across sessions\n6. Verify defaults are applied for new users",
        "priority": "medium",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Onboarding Flow Implementation",
        "description": "Implement the onboarding flow for new users including preset selection, signal weight adjustment, repository selection, and sample work items preview.",
        "details": "1. Implement onboarding API endpoints:\n   - GET /api/onboarding/status\n   - POST /api/onboarding/complete\n2. Create onboarding UI components:\n   - Multi-step wizard interface\n   - Preset selection screen\n   - Signal weight adjustment sliders\n   - Repository selection with search\n   - Sample \"My Work\" preview\n3. Implement onboarding state management:\n   - Track progress through steps\n   - Allow skipping/resuming\n   - Store partial progress\n4. Add onboarding completion logic:\n   - Apply selected settings\n   - Mark onboarding as complete\n   - Redirect to main dashboard",
        "testStrategy": "1. Test onboarding API endpoints\n2. Verify wizard navigation works correctly\n3. Test preset application and customization\n4. Verify repository search and selection\n5. Test sample preview generation\n6. Verify settings are correctly applied on completion\n7. Test skipping and resuming functionality",
        "priority": "medium",
        "dependencies": [
          6,
          7,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Realtime Updates with SSE/WebSocket",
        "description": "Implement server-sent events (SSE) or WebSocket for real-time updates after sync operations complete.",
        "details": "1. Implement SSE endpoint:\n   - GET /api/stream\n   - Authenticate with JWT\n   - Create event stream per user\n2. Add event publishing:\n   - Emit events after sync completes\n   - Include changed entity types and IDs\n   - Format events for client consumption\n3. Implement client-side event handling:\n   - Connect to SSE endpoint\n   - Parse incoming events\n   - Update UI components based on event type\n   - Handle reconnection on errors\n4. Add connection status indicator in UI",
        "testStrategy": "1. Test SSE endpoint authentication\n2. Verify events are emitted after sync\n3. Test client-side event handling with various event types\n4. Verify UI updates correctly when events arrive\n5. Test reconnection behavior on network interruption\n6. Measure performance with many concurrent connections",
        "priority": "medium",
        "dependencies": [
          4,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Observability and Error Handling",
        "description": "Implement structured logging, metrics collection, and comprehensive error handling throughout the application.",
        "details": "1. Implement structured logging:\n   - Add request ID to all logs\n   - Log request/response details\n   - Configure log levels\n   - Format logs for development and production\n2. Add metrics collection:\n   - Request count and latency\n   - Error rates\n   - Sync durations\n   - Cache hit rates\n   - GitHub API rate limit usage\n3. Implement comprehensive error handling:\n   - Create error types and mapping\n   - Add user-friendly error messages\n   - Handle GitHub API errors gracefully\n   - Implement rate limit detection and backoff\n4. Add health check endpoint with detailed status",
        "testStrategy": "1. Verify logs contain required fields\n2. Test metrics collection with various scenarios\n3. Verify error handling for common failure cases\n4. Test rate limit detection and backoff behavior\n5. Verify health check endpoint returns accurate status\n6. Test log levels configuration",
        "priority": "medium",
        "dependencies": [
          1,
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-20T03:07:54.317Z",
      "updated": "2025-08-20T03:07:54.317Z",
      "description": "Tasks for master context"
    }
  }
}